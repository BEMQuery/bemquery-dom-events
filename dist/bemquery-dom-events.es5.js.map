{"version":3,"file":null,"sources":["../src/ListenersStorage.js","../src/listeners.js"],"sourcesContent":["'use strict';\n\n/** Storage for events listeners */\nclass ListenersStorage {\n\t/**\n\t * Creates new storage for event lsiteners\n\t *\n\t * @class\n\t */\n\tconstructor() {\n\t\tthis.storage = new WeakMap();\n\t}\n\n\t/**\n\t * Adds event listener to the storage.\n\t *\n\t * @param {Object} element Element to which listener is binded.\n\t * @param {String} type Type of event.\n\t * @param {String} selector Selector for event delegation.\n\t * @param {Function} fn Original callback.\n\t * @param {Function} listener Created listener.\n\t * @return {void}\n\t */\n\tadd( element, type, selector, fn, listener ) {\n\t\tlet listeners = {};\n\n\t\tif ( this.storage.has( element ) ) {\n\t\t\tlisteners = this.storage.get( element );\n\t\t}\n\n\t\tif ( typeof listeners[ type ] === 'undefined' ) {\n\t\t\tlisteners[ type ] = {};\n\t\t}\n\n\t\tif ( typeof listeners[ type ][ selector ] === 'undefined' ) {\n\t\t\tlisteners[ type ][ selector ] = [];\n\t\t}\n\n\t\tlisteners[ type ][ selector ].push( [ fn, listener ] );\n\n\t\tthis.storage.set( element, listeners );\n\t}\n\n\t/**\n\t * Gets event listener that matches the given criteria.\n\t *\n\t * @param {Object} element Element to which listener is binded.\n\t * @param {String} type Type of event.\n\t * @param {String} selector Selector for event delegation.\n\t * @param {Function} fn Original callback.\n\t * @return {Function} Event listener.\n\t */\n\tget( element, type, selector, fn ) {\n\t\tif ( !this.storage.has( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst listeners = this.storage.get( element );\n\n\t\tif ( typeof listeners[ type ] === 'undefined' || typeof listeners[ type ][ selector ] === 'undefined' ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfor ( let pair of listeners[ type ][ selector ] ) { // eslint-disable-line prefer-const\n\t\t\tif ( pair[ 0 ] === fn ) {\n\t\t\t\treturn pair[ 1 ];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes event listener that matches the given criteria.\n\t *\n\t * @param {Object} element Element to which listener is binded.\n\t * @param {String} type Type of event.\n\t * @param {String} selector Selector for event delegation.\n\t * @param {Function} fn Original callback.\n\t * @return {Function} Event listener.\n\t */\n\tremove( element, type, selector, fn ) {\n\t\tif ( !this.storage.has( element ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst listeners = this.storage.get( element );\n\n\t\tif ( typeof listeners[ type ] === 'undefined' || typeof listeners[ type ][ selector ] === 'undefined' ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlisteners[ type ][ selector ].forEach( ( pair, i ) => {\n\t\t\tif ( pair[ 0 ] === fn ) {\n\t\t\t\tlisteners[ type ][ selector ].splice( i, 1 );\n\t\t\t}\n\t\t} );\n\n\t\treturn null;\n\t}\n}\n\nexport default ListenersStorage;\n","'use strict';\n\nimport { BEMQuery as BEMQuery } from 'bemquery-core';\nimport ListenersStorage from './ListenersStorage';\n\nconst storage = new ListenersStorage();\n\n/**\n * Method for adding event listener to the element.\n *\n * @param {String} type Type of the event.\n * @param {String|Function} selector If that parameter is a string,\n * then it's used to construct checking for the event delegation.\n * However if function is passed, then it becomes the event's listener.\n * @param {Function} callback If the second parameter is a string, this\n * function will be used as an event's listener.\n * @return {BEMQuery} Current BEMQuery instance.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.on = function( type, selector, callback ) {\n\tlet listener;\n\n\tif ( typeof type !== 'string' || !type ) {\n\t\tthrow new TypeError( 'Type of event must be a non-empty string.' );\n\t}\n\n\tif ( ( typeof selector !== 'string' && typeof selector !== 'function' ) || !selector ) {\n\t\tthrow new TypeError( 'Selector must be a non-empty string or function.' );\n\t}\n\n\tif ( typeof selector === 'string' ) {\n\t\tif ( typeof callback !== 'function' ) {\n\t\t\tthrow new TypeError( 'Callback must be a function.' );\n\t\t}\n\n\t\tselector = this.converter.convert( selector ).CSS;\n\t\tselector = `${selector}, ${selector} *`;\n\n\t\tlistener = ( evt ) => {\n\t\t\tif ( evt.target.matches( selector ) ) {\n\t\t\t\tcallback( evt );\n\t\t\t}\n\t\t};\n\t} else {\n\t\tlistener = selector;\n\t}\n\n\tthis.elements.forEach( ( element ) => {\n\t\telement.addEventListener( type, listener, false );\n\n\t\tif ( typeof selector === 'string' ) {\n\t\t\tstorage.add( element, type, selector, callback, listener );\n\t\t}\n\t} );\n\n\treturn this;\n};\n\n/**\n * Method for removing event listener from the element.\n *\n * @param {String} type Type of the event.\n * @param {String|Function} selector If that parameter is a string,\n * then it's used to construct checking for the event delegation.\n * However if function is passed, then it becomes the event's listener.\n * @param {Function} callback If the second parameter is a string, this\n * function will be used as an event's listener.\n * @return {BEMQuery} Current BEMQuery instance.\n * @memberof BEMQuery\n */\nBEMQuery.prototype.off = function( type, selector, callback ) {\n\tlet listener;\n\n\tif ( typeof type !== 'string' || !type ) {\n\t\tthrow new TypeError( 'Type of event must be a non-empty string.' );\n\t}\n\n\tif ( ( typeof selector !== 'string' && typeof selector !== 'function' ) || !selector ) {\n\t\tthrow new TypeError( 'Selector must be a non-empty string or function.' );\n\t}\n\n\tif ( typeof selector === 'string' ) {\n\t\tif ( typeof callback !== 'function' ) {\n\t\t\tthrow new TypeError( 'Callback must be a function.' );\n\t\t}\n\n\t\tselector = this.converter.convert( selector ).CSS;\n\t\tselector = `${selector}, ${selector} *`;\n\t} else {\n\t\tlistener = selector;\n\t}\n\n\tthis.elements.forEach( ( element ) => {\n\t\tif ( typeof selector === 'string' ) {\n\t\t\tlistener = storage.get( element, type, selector, callback );\n\n\t\t\tstorage.remove( element, type, selector, callback );\n\t\t}\n\t\telement.removeEventListener( type, listener, false );\n\t} );\n\n\treturn this;\n};\n"],"names":["ListenersStorage","storage","WeakMap","element","type","selector","fn","listener","listeners","this","has","get","push","set","pair","forEach","i","splice","BEMQuery","prototype","on","callback","TypeError","converter","convert","CSS","evt","target","matches","elements","addEventListener","add","off","remove","removeEventListener"],"mappings":"uiBAGMA,yCAOCC,QAAU,GAAIC,+CAafC,EAASC,EAAMC,EAAUC,EAAIC,MAC7BC,KAECC,MAAKR,QAAQS,IAAKP,OACVM,KAAKR,QAAQU,IAAKR,IAGG,mBAAtBK,GAAWJ,OACXA,OAGkC,mBAAlCI,GAAWJ,GAAQC,OACnBD,GAAQC,SAGTD,GAAQC,GAAWO,MAAQN,EAAIC,SAErCN,QAAQY,IAAKV,EAASK,+BAYvBL,EAASC,EAAMC,EAAUC,OACvBG,KAAKR,QAAQS,IAAKP,SAChB,SAGFK,GAAYC,KAAKR,QAAQU,IAAKR,MAEF,mBAAtBK,GAAWJ,IAAmE,mBAAlCI,GAAWJ,GAAQC,SACnE,6CAGUG,EAAWJ,GAAQC,kDAAa,IAAxCS,cACJA,EAAM,KAAQR,QACXQ,GAAM,uFAIR,qCAYAX,EAASC,EAAMC,EAAUC,OAC1BG,KAAKR,QAAQS,IAAKP,SAChB,SAGFK,GAAYC,KAAKR,QAAQU,IAAKR,SAEF,mBAAtBK,GAAWJ,IAAmE,mBAAlCI,GAAWJ,GAAQC,GACnE,QAGGD,GAAQC,GAAWU,QAAS,SAAED,EAAME,GACzCF,EAAM,KAAQR,KACPF,GAAQC,GAAWY,OAAQD,EAAG,KAIpC,eC7FHf,EAAU,GAAID,EAcpBkB,YAASC,UAAUC,GAAK,SAAUhB,EAAMC,EAAUgB,MAC7Cd,aAEiB,gBAATH,KAAsBA,OAC3B,IAAIkB,WAAW,gDAGK,gBAAbjB,IAA6C,kBAAbA,KAA8BA,OACrE,IAAIiB,WAAW,uDAGG,gBAAbjB,GAAwB,IACV,kBAAbgB,QACL,IAAIC,WAAW,kCAGXb,KAAKc,UAAUC,QAASnB,GAAWoB,MAChCpB,OAAaA,SAEhB,SAAEqB,GACPA,EAAIC,OAAOC,QAASvB,MACdqB,WAIDrB,cAGPwB,SAASd,QAAS,SAAEZ,KAChB2B,iBAAkB1B,EAAMG,GAAU,GAEjB,gBAAbF,MACH0B,IAAK5B,EAASC,EAAMC,EAAUgB,EAAUd,KAI3CE,MAeRS,WAASC,UAAUa,IAAM,SAAU5B,EAAMC,EAAUgB,MAC9Cd,aAEiB,gBAATH,KAAsBA,OAC3B,IAAIkB,WAAW,gDAGK,gBAAbjB,IAA6C,kBAAbA,KAA8BA,OACrE,IAAIiB,WAAW,uDAGG,gBAAbjB,GAAwB,IACV,kBAAbgB,QACL,IAAIC,WAAW,kCAGXb,KAAKc,UAAUC,QAASnB,GAAWoB,MAChCpB,OAAaA,cAEhBA,cAGPwB,SAASd,QAAS,SAAEZ,GACC,gBAAbE,OACAJ,EAAQU,IAAKR,EAASC,EAAMC,EAAUgB,KAEzCY,OAAQ9B,EAASC,EAAMC,EAAUgB,MAElCa,oBAAqB9B,EAAMG,GAAU,KAGvCE"}